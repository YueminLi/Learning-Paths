---
title: "Lab9-Support Vector Machines"
output: html_document
---

# package and library
```{r}
install.packages("e1071")
install.packages("ROCR")
```

```{r}
library(e1071)
library(ROCR)
```


# Support Vector Classifier
```{r}
# generate observations
set.seed(1)
x = matrix(rnorm(20*2), ncol=2)
y = c(rep(-1,10), rep(1,10))
x[y==1,] = x[y==1,] + 1
plot(x, col=(3-y))

# code response as factor variable
dat = data.frame(x=x, y=as.factor(y))

# fit svm()
svmfit = svm(y ~ ., data=dat, kernel="linear", cost=10, scale=FALSE)
plot(svmfit, dat)
summary(svmfit)

# cross-validation use tune()
set.seed(1)
tune.out = tune(svm, y ~ ., data=dat, kernel="linear", ranges=list(cost=c(0.001,0.01,0.1,1.5,10,100)))
summary(tune.out)
# store the best model
bestmod = tune.out$best.model
summary(bestmod)

# predict
# generate a test set
xtest = matrix(rnorm(20*2), ncol=2)
ytest = sample(c(-1,1), 20, rep=TRUE)
xtest[ytest==1,] = xtest[ytest==1,] + 1
testdat = data.frame(x=xtest, y=as.factor(ytest))
# predict
ypred = predict(bestmod, testdat)
table(predict=ypred, truth=testdat$y)
```


# Support Vector Machine
```{r}
# generate observations
set.seed(1)
x = matrix(rnorm(200*2), ncol=2)
x[1:100,] = x[1:100,] + 2
x[101:150,] = x[101:150,] - 2
y = c(rep(1,150), rep(2,50))
dat = data.frame(x=x, y=as.factor(y))
plot(x, col=y)

# split in train and test set
train = sample(200, 100)

# fit svm() with a radial kernel and gamma=1
svmfit = svm(y ~ ., data=dat[train,], kernel="radial", gamma=1, cost=1)
plot(svmfit, dat[train,])
summary(svmfit)

# cross-validation use tune()
set.seed(1)
tune.out = tune(svm, y ~ ., data=dat[train,], kernel="radial", ranges=list(cost=c(0.1,1,10,100,1000), gamma=c(0.5,1,2,3,4)))
summary(tune.out)
table(true=dat[-train,"y"], pred=predict(tune.out$best.model, newx=dat[-train,]))
```


# ROC Curves
```{r}
rocplot = function(pred, truth, ...){
  predob = prediction(pred, truth)
  perf = performance(predob, "tpr", "fpr")
  plot(perf, ...)
}

svmfit.opt = svm(y ~ ., data=dat[train,], kernel="radial", gamma=2, cost=1, decision.values=T)
fitted = attributes(predict(svmfit.opt, dat[train,], decision.values=TRUE))$decision.values
par(mfrow=c(1,2))
rocplot(fitted, dat[train,"y"], main="Training Data")

# increase gamma to obatin a more flexible fit
svmfit.flex = svm(y ~ ., data=dat[train,], kernel="radial", gamma=50, cost=1, decision.values=T)
fitted = attributes(predict(svmfit.flex, dat[train,], decision.values=T))$decision.values
rocplot(fitted, dat[train,"y"], add=T, col="red")

# roc plot for test data
fitted = attributes(predict(svmfit.opt, dat[-train,], decision.values=T))$decision.values
rocplot(fitted, dat[-train,"y"], main="Test Data")
fitted = attributes(predict(svmfit.flex, dat[-train,], decision.values=T))$decision.values
rocplot(fitted, dat[-train,"y"], add=T, col="red")
```


# SVM with Multiple Classes
```{r}
# generate a third class of observations
set.seed(1)
x = rbind(x, matrix(rnorm(50*2), ncol=2))
y = c(y, rep(0,50))
x[y==0,2] = x[y==0,2]+2
dat = data.frame(x=x, y=as.factor(y))
par(mfrow = c(1,1))
plot(x, col=(y+1))

# fit svm() with one-versus-one approach
svmfit = svm(y ~ ., data=dat, kernel="radial", cost=10, gamma=1)
plot(svmfit, dat)
```




























